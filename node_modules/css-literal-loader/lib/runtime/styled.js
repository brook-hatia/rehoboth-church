"use strict";

exports.__esModule = true;
exports.styled = styled;
exports.css = exports.default = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _camelCase = _interopRequireDefault(require("lodash/camelCase"));

var _react = _interopRequireDefault(require("react"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

// eslint-disable-line import/no-extraneous-dependencies
const has = Object.prototype.hasOwnProperty;

function styled(type, options, displayName, styles, kebabName, camelName) {
  const componentClassName = has.call(styles, kebabName) ? styles[kebabName] : styles[camelName];
  const hasModifiers = Object.keys(styles).some(className => className !== camelName && className !== kebabName);

  function Styled(props) {
    const childProps = _extends({}, props);

    delete childProps.innerRef;
    childProps.ref = props.innerRef;

    if (hasModifiers) {
      const modifierClassNames = [];
      Object.keys(props).forEach(propName => {
        const propValue = props[propName];

        if (typeof propValue === 'boolean') {
          if (has.call(styles, propName)) {
            if (propValue) {
              modifierClassNames.push(styles[propName]);
            }

            delete childProps[propName];
          } else {
            const camelPropName = (0, _camelCase.default)(propName);

            if (has.call(styles, camelPropName)) {
              if (propValue) {
                modifierClassNames.push(styles[camelPropName]);
              }

              delete childProps[propName];
            }
          }
        } else if (typeof propValue === 'string' || typeof propValue === 'number') {
          const propKey = `${propName}-${propValue}`;

          if (has.call(styles, propKey)) {
            modifierClassNames.push(styles[propKey]);
            delete childProps[propName];
          } else {
            const camelPropKey = (0, _camelCase.default)(propKey);

            if (has.call(styles, camelPropKey)) {
              modifierClassNames.push(styles[camelPropKey]);
              delete childProps[propName];
            }
          }
        }
      });
      childProps.className = (0, _classnames.default)(childProps.className, componentClassName, ...modifierClassNames);
    } else {
      childProps.className = (0, _classnames.default)(childProps.className, componentClassName);
    }

    return _react.default.createElement(type, childProps);
  }

  Styled.displayName = displayName;
  const decorated = _react.default.forwardRef ? _react.default.forwardRef((props, ref) => _react.default.createElement(Styled, _extends({
    innerRef: ref
  }, props))) : Styled;

  decorated.withComponent = nextType => styled(nextType, displayName, styles, kebabName, camelName);

  return decorated;
}

var _default = styled;
exports.default = _default;

const css = () => {
  throw new Error('`css` template literal evaluated at runtime!');
};

exports.css = css;